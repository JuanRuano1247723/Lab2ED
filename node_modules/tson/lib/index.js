// Generated by CoffeeScript 1.10.0

/* 
 * Parse a turtle-like CSON syntax
 */

(function() {
  var CSON, Fs, TSON;

  Fs = require('fs');

  CSON = require('cson');

  TSON = (function() {
    function TSON() {}

    TSON.prototype._quoteValueIfNecessary = function(s) {
      s = s.replace(/^<(.*)>$/, function(match, uri) {
        return "'" + uri + "'";
      });
      if (/^["'].*["']$/.test(s)) {
        return s;
      }
      if (/^[\d\.]+$/.test(s)) {
        return s;
      }
      if (/^(true|false|yes|no|on|off)$/.test(s)) {
        return s;
      }
      if (/[\[\{]\s*$/.test(s)) {
        return s;
      }
      if (/[\]\}]\s*$/.test(s)) {
        return s;
      }
      return "'" + s + "'";
    };

    TSON.prototype._convertLine = function(line) {
      var self;
      self = this;
      line = line.replace(/\s*$/, '');
      return line.replace(/^(\s*)([^\s]+[^:\s])\s*(:?\s*)?([^\s].*)?\s*$/, function(match, indent, key, delim, val) {
        var hit, ret;
        hit = true;
        if (/['"#]{3}/.test(key)) {
          return line;
        }
        if (/[\}\]]/.test(key)) {
          return line;
        }
        ret = indent;
        key = key.replace(/^[^"']+$/, function(s) {
          return "'" + s + "'";
        });
        ret += key;
        ret += ": ";
        if (val) {
          val = self._quoteValueIfNecessary(val);
          ret += val;
        }
        return ret;
      });
    };

    TSON.prototype._convertToCSON = function(inText) {
      var hit, i, len, line, mlArray, mlComment, mlString, outText, ref, self;
      self = this;
      outText = '';
      mlComment = null;
      mlString = null;
      mlArray = null;
      ref = inText.split(/\n/);
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        if (!(mlString || mlArray || mlComment || /^\s*##?[^#]/.test(line) || /[\[\]\{\}]/.test(line))) {
          hit = false;
          line = self._convertLine(line);
        }
        if (mlString && line.indexOf(mlString) > -1) {
          mlString = null;
        } else if (!mlString) {
          line.replace(/('''|""")/, function(match) {
            return mlString = match;
          });
        }
        if (mlArray) {
          if (/\]\s*$/.test(line)) {
            mlArray = null;
          } else {
            line = line.replace(/^(\s*)([^\s].*)\s*/, function(match, indent, val) {
              val = self._quoteValueIfNecessary(val);
              return "" + indent + val;
            });
          }
        } else if (!mlArray) {
          line.replace(/\[\s*$/, function(match) {
            return mlArray = true;
          });
        }
        if (mlComment && line.indexOf(mlComment) > -1) {
          mlComment = null;
        } else if (!mlComment) {
          line.replace(/###/, function(match) {
            return mlComment = match;
          });
        }
        outText += line;
        outText += "\n";
      }
      return outText;
    };

    TSON.prototype.parseCSON = function(inText) {
      return this._convertToCSON(inText);
    };

    TSON.prototype.loadCSON = function(file) {
      var inText;
      inText = Fs.readFileSync(file);
      if (inText instanceof Error) {
        return inText;
      }
      return this.parseCSON(inText.toString());
    };

    TSON.prototype.parse = function() {
      return this.parseString.apply(this, arguments);
    };

    TSON.prototype.parseString = function(inText) {
      return CSON.parseString(this.parseCSON(inText));
    };

    TSON.prototype.load = function() {
      return this.loadFile.apply(this, arguments);
    };

    TSON.prototype.loadFile = function(file) {
      return this.parseString(this.loadCSON(file));
    };

    return TSON;

  })();

  module.exports = new TSON;

}).call(this);
